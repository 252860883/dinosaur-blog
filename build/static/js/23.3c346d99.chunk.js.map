{"version":3,"sources":["components/headerLink.tsx","article/前端的两种路由.js"],"names":["Main","clickPosBtn","idName","dom","document","getElementById","window","scrollTo","top","offsetTop","left","behavior","_this2","this","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","className","props","headerLink","map","item","index","level","key","onClick","title","React","Component","Template","_this","Object","_Users_honghuidu_homework_dinosaur_blog_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_Users_honghuidu_homework_dinosaur_blog_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_Users_honghuidu_homework_dinosaur_blog_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","state","react__WEBPACK_IMPORTED_MODULE_5__","_components_headerLink__WEBPACK_IMPORTED_MODULE_7__","id","src","alt"],"mappings":"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","file":"static/js/23.3c346d99.chunk.js","sourcesContent":["import React from 'react'\nimport \"../style/components/headerLink.scss\"\nexport default class Main extends React.Component<any, any>{\n    componentDidMount() { }\n\n    clickPosBtn = (idName: string) => {\n        const dom: any = document.getElementById(idName);\n        window.scrollTo({\n            top: dom.offsetTop - 10,\n            left: 0,\n            behavior: 'smooth'\n        });\n    }\n\n    render() {\n        return (\n            <div className=\"headerLink\">\n                <div className=\"content\">\n                    <div className=\"real-content\">\n                        <div className='tag'>Reading Assistance ·</div>\n                        {\n                            this.props.headerLink.map((item: any, index: number) => {\n                                return <span className={'a' + item.level} key={index} onClick={() => this.clickPosBtn(item.title)}>{item.title}</span>\n                            })\n                        }\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}","import React, { Fragment } from 'react'\nimport '../style/main.scss'\nimport HeaderLink from \"../components/headerLink\"\nexport default class Template extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            headerLink: [{\"level\":\"h2\",\"title\":\"Hash模式\"},{\"level\":\"h2\",\"title\":\"History模式\"},{\"level\":\"h3\",\"title\":\"两种模式比较\"}]\n        }\n    }\n    componentWillMount(){\n    }\n    componentDidMount() {\n    }\n    render() {\n        return (\n            <Fragment>\n                <HeaderLink headerLink={this.state.headerLink}></HeaderLink>\n                <div className=\"article\">\n<div className=\"title-content\"><h1 className=\"title\">前端两种路由的实现原理</h1></div>\n<blockquote>\n  <p>过去,路由都是由后端实现，直接根据url来重载页面，但随着前端的工程越来越复杂，服务器压力变大。后来我们可以通过记录 url 来记录 ajax 的变化。再到后来的SPA的出现，为了实现单页应用从而出现了前端路由。在这里主要讲解前端路由的两种实现方式：history模式和hash模式。</p>\n</blockquote>\n\n<h2 id='Hash模式'>Hash模式</h2>\n\n<p>在URL中看到 # 有两种可能，一种是我们熟知的锚点，比如点击回到顶部等等，另一种就是我们这里说到的hash路由了。许多框架，比如我们看到的vue-router等都用到了hash模式。<br></br>实现hash模式的核心就是：<strong>hashchange事件</strong>，它可以监听地址的hash值的变化。下面用原生js来一步步实现一个hash路由。</p>\n\n<ol>\n<li>首先实现一个构造函数Router:</li>\n</ol>\n\n<pre><code><span></span>\n<span>// 创建构造函数</span>\n<span>function Router(routes) {'{'}</span>\n<span>    this.routes = routes</span>\n<span>}</span>\n<span>//注册路由</span>\n<span>Router.prototype.init = function () {'{'}</span>\n<span>    // 坚听路由变化</span>\n<span>    window.addEventListener('hashchange', this.update.bind(this));</span>\n<span>    // 监听页面加载</span>\n<span>    window.addEventListener('load', this.update.bind(this));</span>\n<span>}</span>\n<span>// 更新路由</span>\n<span>Router.prototype.update = function () {'{'}</span>\n<span>    let hashPath = location.hash.split('#')[1];</span>\n<span>    let routerData = this.routes.filter(item =&gt; item.path === hashPath)[0]</span>\n<span>    // 这里进行模拟组件切换操作</span>\n<span>    document.getElementById('app').innerHTML =  routerData.component;</span>\n<span>}</span>\n<span></span>\n</code></pre>\n\n<p>从上面代码知道，首先我们需要一个盛放路由配置的容器 <code>routes</code> , <code>update方法</code> 即地址路由更新时根据 path 在路由容器里找到对应的路由信息并执行相关操作；<code>init</code> 即注册路由，将路由更新操作绑定在 <code>load</code> 和 <code>hashchange</code> 事件上。</p>\n\n<ol>\n<li>下面我们可以在实际生产环境进行使用：</li>\n</ol>\n\n<pre><code><span></span>\n<span>&lt;body&gt;</span>\n<span>    &lt;a href=\"#/a\"&gt;切换a路由&lt;/a&gt;</span>\n<span>    &lt;a href=\"#/b\"&gt;切换b路由&lt;/a&gt;</span>\n<span>    &lt;a href=\"#/c\"&gt;切换c路由&lt;/a&gt;</span>\n<span>    &lt;div id=\"app\"&gt;&lt;/div&gt;</span>\n<span>&lt;/body&gt;</span>\n<span>&lt;script&gt;</span>\n<span>    // 路由配置文件</span>\n<span>    let router = [</span>\n<span>        {'{'} path: 'a', component: 'a页面' },</span>\n<span>        {'{'} path: 'b', component: 'b页面' },</span>\n<span>        {'{'} path: 'c', component: 'c页面' }</span>\n<span>    ]</span>\n<span>    let route = new Router(router);</span>\n<span>    route.init()</span>\n<span>&lt;/script&gt;</span>\n<span></span>\n</code></pre>\n\n<p>来看看实际效果：<br></br><img src=\"http://wx4.sinaimg.cn/large/a73bc6a1ly1g523tcdr2sg20ps0g4hdv.gif\" alt=\"image\" title=\"\" /><br></br>由此原理，可以在vue等单页面SPA中通过路由的变化来决定显示哪些模块。</p>\n\n<h2 id='History模式'>History模式</h2>\n\n<p>vue-router 同时也支持 H5 history模式的路由，其主要原理用到了 H5 History 新增的两个API: <code>history.pushState()</code>  和  <code>history.replaceState()</code> 。这两个API的作用是可以操作浏览器的历史记录，而不会引起页面的刷新。但不同之处是pushState会增加一条新的记录，而后者是直接替换当前的历史记录。<br></br>同时也需要配合 <code>onpopstate</code>事件来实现,它可以监听浏览器的前进后退事件，当我们点击前进后退的时候可以使得路由同时受控。</p>\n\n<p><code>pushState()</code> 和 <code>replaceState()</code> 接受三个对象，分别是：<br></br>1. <strong>状态对象</strong>,  opstate事件监听时，可以通过 <code>event.state</code> 拿到该对象，状态对象不能超过 640k,如果数据较大建议用缓存实现<br></br>2. <strong>标题</strong><br></br>3. <strong>URL</strong>,该参数定义了新的URL，但是页面不会进行刷新</p>\n\n<p>具体实现见下方代码：</p>\n\n<pre><code><span></span>\n<span>&lt;body&gt;</span>\n<span>    &lt;button id=\"a\" onClick='clickHandler()'&gt;切换a路由&lt;/button&gt;</span>\n<span>    &lt;button id=\"b\" onClick='clickHandler()'&gt;切换b路由&lt;/button&gt;</span>\n<span>    &lt;button id=\"c\" onClick='clickHandler()'&gt;切换c路由&lt;/button&gt;</span>\n<span>    &lt;div id=\"app\"&gt;&lt;/div&gt;</span>\n<span>&lt;/body&gt;</span>\n<span>&lt;script&gt;</span>\n<span>    let routerMap = [</span>\n<span>        {'{'} path: 'a', component: 'a页面' },</span>\n<span>        {'{'} path: 'b', component: 'b页面' },</span>\n<span>        {'{'} path: 'c', component: 'c页面' }</span>\n<span>    ]</span>\n<span>    // 监听左右键切换</span>\n<span>    window.onpopstate = function (event) {'{'}</span>\n<span>        let route = event.state.route;</span>\n<span>        handleRoute(route)</span>\n<span>    }</span>\n<span>    // 点击切换路由</span>\n<span>    function clickHandler() {'{'}</span>\n<span>        let route = window.event.target.id;</span>\n<span>        // 向历史记录添加url</span>\n<span>        history.pushState({'{'} route: route }, null, route);</span>\n<span>        // 路由操作</span>\n<span>        handleRoute(route)</span>\n<span>    }</span>\n<span>    // 模拟路由处理</span>\n<span>    function handleRoute(route) {'{'}</span>\n<span>        let routerData = routerMap.filter(item =&gt; item.path === route)[0]</span>\n<span>        document.getElementById('app').innerHTML = routerData.component;</span>\n<span>    }</span>\n<span>&lt;/script&gt;</span>\n<span></span>\n</code></pre>\n\n<p>实现效果：<br></br><img src=\"http://wx1.sinaimg.cn/large/a73bc6a1ly1g523tdmlfng20ps0g4e83.gif\" alt=\"image\" title=\"\" /></p>\n\n<p>但是需要注意，History模式有一个很严重的问题，因为我们的应用是个单页客户端应用，如果刷新页面 <code>xxx.com/history/a</code> 的话就会返回 404。所以需要在服务端配置，增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面。对此，vue-router 官方文档已经给了很详细的示例。</p>\n\n<h3 id='两种模式比较'>两种模式比较</h3>\n\n<p><strong>Hash模式：</strong> </p>\n\n<ol>\n<li>实现方式较为简单，可以通过<code>&lt;a&gt;</code>标签或者<code>location.hash=xxx</code>改变地址的hash值</li>\n<li>直接通过<code>hashchange</code>监听hash值的变化，兼容性较好</li>\n<li>hash值的改变，都会在浏览器的访问历史中增加一个记录，能通过浏览器的回退、前进按钮控制hash的切换</li>\n<li>URL中的hash值只是客户端的状态，当向服务器端发出请求时hash部分不会被发送，不利于SEO</li>\n</ol>\n\n<p><strong>History模式：</strong> </p>\n\n<ol>\n<li>需要用到<code>pushState</code>和<code>repalceState</code>两个API来操作实现URL的变化，存在兼容性问题</li>\n<li>通过<code>popstate</code>事件来监听URL的变化，，存在兼容性问题</li>\n<li>没有“丑陋”的“#”看起来像正常的URL</li>\n<li>需要后端配置配合，否则刷新页面会出现404，因为服务器会认为路由部分是文件路径</li>\n</ol>\n</div>\n            </Fragment>\n        )\n    }\n}"],"sourceRoot":""}