{"version":3,"sources":["components/headerLink.tsx","article/JavaScript 继承.js"],"names":["Main","clickPosBtn","idName","dom","document","getElementById","window","scrollTo","top","offsetTop","left","behavior","_this2","this","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","className","props","headerLink","map","item","index","level","key","onClick","title","React","Component","Template","_this","Object","_Users_honghuidu_homework_dinosaur_blog_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_Users_honghuidu_homework_dinosaur_blog_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_Users_honghuidu_homework_dinosaur_blog_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","state","react__WEBPACK_IMPORTED_MODULE_5__","_components_headerLink__WEBPACK_IMPORTED_MODULE_7__","id","target","href"],"mappings":"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","file":"static/js/1.1523cb0f.chunk.js","sourcesContent":["import React from 'react'\nimport \"../style/components/headerLink.scss\"\nexport default class Main extends React.Component<any, any>{\n    componentDidMount() { }\n\n    clickPosBtn = (idName: string) => {\n        const dom: any = document.getElementById(idName);\n        window.scrollTo({\n            top: dom.offsetTop - 10,\n            left: 0,\n            behavior: 'smooth'\n        });\n    }\n\n    render() {\n        return (\n            <div className=\"headerLink\">\n                <div className=\"content\">\n                    <div className=\"real-content\">\n                        <div className='tag'>Reading Assistance ·</div>\n                        {\n                            this.props.headerLink.map((item: any, index: number) => {\n                                return <span className={'a' + item.level} key={index} onClick={() => this.clickPosBtn(item.title)}>{item.title}</span>\n                            })\n                        }\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}","import React, { Fragment } from 'react'\nimport '../style/main.scss'\nimport HeaderLink from \"../components/headerLink\"\nexport default class Template extends React.Component {\n    constructor() {\n        super();\n        this.state = {\n            headerLink: [{\"level\":\"h3\",\"title\":\"原型链继承\"},{\"level\":\"h3\",\"title\":\"借用构造函数继承\"},{\"level\":\"h3\",\"title\":\"组合继承\"},{\"level\":\"h3\",\"title\":\"原型式继承\"},{\"level\":\"h3\",\"title\":\"寄生式继承\"},{\"level\":\"h3\",\"title\":\"寄生组合继承\"},{\"level\":\"h3\",\"title\":\"ES6 Class extends\"},{\"level\":\"h3\",\"title\":\"参考\"}]\n        }\n    }\n    componentWillMount(){\n    }\n    componentDidMount() {\n    }\n    render() {\n        return (\n            <Fragment>\n                <HeaderLink headerLink={this.state.headerLink}></HeaderLink>\n                <div className=\"article\">\n<div className=\"title-content\"><h1 className=\"title\">JavaScript 继承的几种方式</h1></div>\n<h3 id='原型链继承'>原型链继承</h3>\n\n<p>原型链继承的核心就是将子类的原型对象指向父类实例，<code>Student.prototype = new Person()</code> 。</p>\n\n<pre><code><span></span>\n<span>// 父类</span>\n<span>function Person(age) {'{'}</span>\n<span>    this.arr = []   </span>\n<span>    this.age = age        </span>\n<span>}</span>\n<span>// 子类</span>\n<span>function Student(name) {'{'}</span>\n<span>    this.name = name                 </span>\n<span>    this.score = 80                  </span>\n<span>}</span>\n<span>// 继承</span>\n<span>Student.prototype = new Person()</span>\n<span></span>\n</code></pre>\n\n<p>原型链继承非常的简单方便，但问题也是显而易见的，父类的实例被所以子类共享，如果共享的属性是引用类型，那么其中一个子类对该值进行操作，其他子类都会被更新:</p>\n\n<pre><code><span></span>\n<span>let student1 = new Student('std1');</span>\n<span>let student2 = new Student('std2');</span>\n<span>student1.arr.push('stu1')</span>\n<span>console.log(student2.arr) // ['stu1']  父类的值被修改</span>\n<span></span>\n</code></pre>\n\n<p>同时原型链继承很严重的一个缺陷是，无法通过子类向父类传参。</p>\n\n<h3 id='借用构造函数继承'>借用构造函数继承</h3>\n\n<p>借用构造函数继承严格来讲并没有用到 prototype 继承，而是直接在子类构造函数里执行父类构造函数：</p>\n\n<pre><code><span></span>\n<span>// 父类</span>\n<span>function Person(name) {'{'}</span>\n<span>    this.arr = []</span>\n<span>    this.name = name</span>\n<span>    this.age = 18</span>\n<span>}</span>\n<span>// 子类</span>\n<span>function Student(name) {'{'}</span>\n<span>    Person.call(this, name) // 执行 Person 的方法</span>\n<span>}</span>\n<span></span>\n</code></pre>\n\n<p>构造函数继承解决了原型链继承的问题，不仅可以对父类进行传参，而且子类实例也不会共享父类实例了（因为每个实例都像拷贝了一份父类而不是引用）：</p>\n\n<pre><code><span></span>\n<span>let student3 = new Student('stu3');</span>\n<span>let student4 = new Student('stu4');</span>\n<span>console.log(student3.name)  // stu3</span>\n<span>student3.arr.push('stu4')</span>\n<span>console.log(student4.name)  // [] 未被修改</span>\n<span></span>\n</code></pre>\n\n<p>但是，新的问题出现了，每个实例都要拷贝一份新的父类，但是如果父类中有像函数这种对象，也不会进行共享了，但是我们完全没必要拷贝多份呀！</p>\n\n<h3 id='组合继承'>组合继承</h3>\n\n<p>为了解决上述两种继承方法的各自的问题，组合式继承出现了，它结合了两种继承的精华：普通的属性放在父类构造函数里，可以给子类共享的放到父类构造函数原型链上：</p>\n\n<pre><code><span></span>\n<span>// 父类</span>\n<span>function Person() {'{'}</span>\n<span>  this.hobbies = ['music','reading']</span>\n<span>}</span>\n<span>// 共享属性放到原型链上</span>\n<span>Person.prototype.say = function() {'{'}console.log('I am a person')}</span>\n<span></span>\n<span>// 子类</span>\n<span>function Student(){'{'}</span>\n<span>    Person.call(this)             </span>\n<span>}</span>\n<span>Student.prototype = new Person()</span>\n<span></span>\n</code></pre>\n\n<p>来验证一下结果：</p>\n\n<pre><code><span></span>\n<span>// 实例化</span>\n<span>var stu1 = new Student()</span>\n<span>var stu2 = new Student()</span>\n<span></span>\n<span>stu1.hobbies.push('basketball')</span>\n<span>console.log(stu1.hobbies)           // music,reading,basketball</span>\n<span>console.log(stu2.hobbies)           // music,reading</span>\n<span></span>\n<span>console.log(stu1.say == stu2.say)   // true</span>\n<span></span>\n</code></pre>\n\n<p>组合继承解决了原型链继承和构造函数继承各自的缺点，是常用的继承方案。但是，我们在组合继承中 <code>Person.call(this)</code> 和 <code>new Person()</code> 时分别实例化了两次父类实例，(由于原型链的优先级 Student 原型链上的父类实例并不会被用到），造成了浪费。所以在最后针对组合继承的缺陷也有对应的解决方案。</p>\n\n<h3 id='原型式继承'>原型式继承</h3>\n\n<p>原型式继承和原型链继承都是基于 prototype 实现继承的，所以都存在引用属性共享的缺陷。 原型式继承的核心是返回一个新对象，该对象的 <code>__proto__</code> 指向父类对象：</p>\n\n<pre><code><span></span>\n<span>function object(o){'{'}</span>\n<span>  function F(){'{'}}</span>\n<span>  F.prototype = o;</span>\n<span>  return new F();</span>\n<span>}</span>\n<span></span>\n</code></pre>\n\n<p>举个例子：</p>\n\n<pre><code><span></span>\n<span>var Person = {'{'}</span>\n<span>  name:'abc',</span>\n<span>  hobbies:['swimming','running']</span>\n<span>}</span>\n<span>var person1 = object(Person);</span>\n<span>person1.age = 18;</span>\n<span>person1.hobbies.push('jumping');</span>\n<span>var person2 = object(Person);</span>\n<span></span>\n<span>console.log(person2.hobbies) // [\"swimming\", \"running\", \"jumping\"]</span>\n<span></span>\n</code></pre>\n\n<blockquote>\n  <p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数:一 个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。——《JAVASCript高级编程》</p>\n</blockquote>\n\n<h3 id='寄生式继承'>寄生式继承</h3>\n\n<p>原型式继承有个问题，只能获取到一个对象的浅复制，但额外的属性需要再手动添加，复用性很差！所以寄生式继承就来解决这个问题：使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。</p>\n\n<pre><code><span></span>\n<span>function object(o){'{'}</span>\n<span>  function F(){'{'}}</span>\n<span>  F.prototype = o;</span>\n<span>  return new F();</span>\n<span>}</span>\n<span>var Animal = {'{'}</span>\n<span>  sex:'male',</span>\n<span>  hobbies:['swimming','running']</span>\n<span>}</span>\n<span></span>\n<span>function Cat(name){'{'}</span>\n<span>    var cat = object(Animal);</span>\n<span>    cat.name=name;</span>\n<span>    return cat;</span>\n<span>}</span>\n<span></span>\n<span>let cat1 = Cat('Kitty');</span>\n<span>cat1.hobbies.push('jumping')</span>\n<span>console.log(cat1.name); // \"Kitty\"</span>\n<span></span>\n<span>let cat2 = Cat('Jenny');</span>\n<span>console.log(cat2.hobbies);  // [\"swimming\", \"running\", \"jumping\"]</span>\n<span></span>\n</code></pre>\n\n<p>需要注意，不管是 原型链继承、原型式继承还是寄生式继承，都是基于prototype实现的，所以都会存在引用类型共享的缺陷！</p>\n\n<h3 id='寄生组合继承'>寄生组合继承</h3>\n\n<p>刚才提到组合继承会实例化两次父类，所以这个继承方案就来解决这个问题。其核心就是：借用构造函数 + 相当于浅拷贝父类的原型对象。</p>\n\n<pre><code><span></span>\n<span>function object(o){'{'}</span>\n<span>  function F(){'{'}}</span>\n<span>  F.prototype = o;</span>\n<span>  return new F();</span>\n<span>}</span>\n<span></span>\n<span>function inheritPrototype(subType, superType){'{'}</span>\n<span>      let prototype = object(superType.prototype)</span>\n<span>      prototype.constructor = subType;// 修正原型的构造函数</span>\n<span>      subType.prototype = prototype;// 将子类的原型替换为这个原型</span>\n<span>}</span>\n<span></span>\n<span>// 父类</span>\n<span>function Person() {'{'}</span>\n<span>  this.hobbies = ['music','reading']</span>\n<span>}</span>\n<span>// 共享属性放到原型链上</span>\n<span>Person.prototype.say = function() {'{'}console.log('I am a person')}</span>\n<span></span>\n<span>// 子类</span>\n<span>function Student(){'{'}</span>\n<span>    Person.call(this)             </span>\n<span>}</span>\n<span>inheritPrototype(Student,Person);</span>\n<span></span>\n<span>// 实例化</span>\n<span>var stu1 = new Student()</span>\n<span>var stu2 = new Student()</span>\n<span></span>\n<span>stu1.hobbies.push('basketball')</span>\n<span>console.log(stu1.hobbies)           // music,reading,basketball</span>\n<span>console.log(stu2.hobbies)           // music,reading</span>\n<span>console.log(stu1.say == stu2.say)   // true</span>\n<span></span>\n</code></pre>\n\n<h3 id='ES6 Class extends'>ES6 Class extends</h3>\n\n<p>ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。但是，寄生组合继承是先创建子类实例this对象，然后再对其增强；而ES6先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>\n\n<pre><code><span></span>\n<span>class B extends A {'{'}</span>\n<span>  constructor() {'{'}</span>\n<span>    super();</span>\n<span>  }</span>\n<span>}</span>\n<span></span>\n<span>// 原理如下：</span>\n<span></span>\n<span>Object.setPrototypeOf = function (obj, proto) {'{'}</span>\n<span>  obj.__proto__ = proto;</span>\n<span>  return obj;</span>\n<span>}</span>\n<span></span>\n<span>// B 的原型对象继承 A 的对象</span>\n<span>Object.setPrototypeOf(B.prototype, A.prototype);</span>\n<span></span>\n<span>// B 继承 A 的静态属性</span>\n<span>Object.setPrototypeOf(B, A);</span>\n<span></span>\n</code></pre>\n\n<h3 id='参考'>参考</h3>\n\n<blockquote>\n  <p><a target=\"_blank\" href=\"https://segmentfault.com/a/1190000015727237\">一篇文章理解JS继承</a><br></br><a target=\"_blank\" href=\"https://segmentfault.com/a/1190000014476341\">JS中的继承(上)</a></p>\n</blockquote>\n</div>\n            </Fragment>\n        )\n    }\n}"],"sourceRoot":""}